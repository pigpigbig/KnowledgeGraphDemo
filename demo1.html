<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <script src="external/d3.v7.min.js"></script>
    <!-- <script src="http://d3js.org/d3.v7.min.js"></script> -->
    
    <script src="external/cytoscape.min.js"></script>
    <!-- <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script> -->

    <!-- for testing with local version of cytoscape.js -->
    <!--<script src="../cytoscape.js/build/cytoscape.js"></script>-->

    <script src="https://unpkg.com/dagre@0.7.4/dist/dagre.js"></script>
    <script src="external/cytoscape-dagre.js"></script>
    <!--<script src="cytoscape.js" type="text/javascript"></script>-->
    
    <style type="text/css">
      #cy {
        display: none;
        height: 200vh;
        width: 175vh;
        border-style: solid;
      }

      .btn {
        background-color: black;
        color: white;
        padding: 10px;
        width: 100px;
      }

      .btn2 {
        background-color: green;
        color: white;
        padding: 10px;
        width: 100px;
      }

      .hierarchy-type {
        background-color: white;
        color: black;
        margin-top: 20px;
        margin-bottom: 20px;
        margin-right: 5px; 
      }

      .hierarchy-button {
        background-color: white;
        margin-top: 20px;
        margin-bottom: 20px;
        width: 10px; 
        height: 10px;
      }
      
    </style>

    <script>

      function getheirarchy(){
        var heirarcy = document.getElementById("heirarchyType").value;
        console.log(heirarcy);
      }


      var my_result;
      var bindings;
      var len
      var nodes;
      var child;
      var parent;
      var data_obj;

    /*convert_to_cytoscape will return an object
    that stores the nodes, the edges, the positions of all
    the nodes, and the ranks for each of the nodes*/
    function convert_to_cytoscape(data) {
        var nodes_lst = []
        var edges_lst = []
        var rank_node_edges = {} //consists of objects that have ranks and nodes that are connected by an edge
        var edge_object = {}

        bindings = data.results.bindings;
        len = bindings.length;
        //adding nodes
        for (let i = 0; i < len; i++){
            child = bindings [i].child_name.value;
            parent = bindings [i].parent_name.value;
            rank = bindings [i].rank_name.value;

            //creating a node for a parent and a child
            data_obj = {data: {id: child, name: child, color: '#ADD8E6', width: 150, height: 150}};
            nodes_lst.push(data_obj);
            data_obj = {data: {id: parent, name: parent, color: '#ADD8E6', width: 150, height: 150}};
            nodes_lst.push(data_obj);
            //creating a node object for rank
            
        }
        //adding edges between parent and child
        for (let i = 0; i < len; i++){
            child = bindings [i].child_name.value;
            parent = bindings [i].parent_name.value;
            rank = bindings [i].rank_name.value;
            
            //adding an edge between the parent and child
            pc_edge = {data: {id: child.concat('-'.concat(parent)), source: child, target: parent, label:'subTaxOnOf'}};
            edges_lst.push(pc_edge);

            edge_object[child] = parent //source is the key and target is the value
            rank_node_edges[child] = rank
            
        }
        rank_node_edges['Animalia'] = 'noRank'
        return {nodes: nodes_lst, edges: edges_lst, rn_edges: rank_node_edges, pc_edges: edge_object};
    }
    //graphType variable is used to keep track of if the Full, Concise, or Moderate button was pressed
    function exec(graphType) {
      var endpoint = d3.select("#endpoint").property("value")
      var sparql = d3.select("#sparql").property("value")
      query(endpoint, sparql, render, graphType)
    }
    function query(endpoint, sparql, callback, graphType){
      var url = endpoint + "?query=" + encodeURIComponent(sparql)
      var res = d3.json(url).then(function(json){
        callback(json, graphType)
      })
    }

    function find_new_target(old_target, rn_edges, pc_edges, correct_ranks){
        //pc_edges is an object where the sources are keys and the values are the targets
        var curr_source = old_target
        var curr_target = pc_edges[curr_source]
        var is_valid_rank = correct_ranks.includes(rn_edges[curr_target])
        
        while (!is_valid_rank) {
           curr_source = curr_target //idea is to keep "climbing up" this tree
           //assumption is that curr_source is never going to be undefined
           curr_target = pc_edges[curr_source]
           is_valid_rank = correct_ranks.includes(rn_edges[curr_target])
        }
        return curr_target
    }
    
    /*so we're given the original nodes and edges and we want to output new nodes/edges
    such that there are only nodes with ranks: 
    [Kingdom, Phylum, Class, Order, Family, Genus, Species] and 
    all missing edges are filled in, also will want to return the rn_edges */
    function create_new(data, correct_ranks){
        //data is of the form: {nodes: nodes_lst, edges: edges_lst, rn_edges: rank_node_edges}
        var nodes = data.nodes
        var edges = data.edges
        var rn_edges = data.rn_edges
        var pc_edges = data.pc_edges  //keys are sources and values are targets
        var new_edges = []
        var new_nodes = []
        var edges_missing = {} //keeps track of the nodes that now no longer have edges because of the removed ranks

        //iterating through all the edges and figuring out which ones are going to be removed 
        for (let i = 0; i < edges.length; i++){
              curr_edge = edges[i]  //of the form: {id: __, source: '', target: '', ...}
              source_node = curr_edge.data.source
              target_node = curr_edge.data.target

              keep_source = correct_ranks.includes(rn_edges[source_node])
              keep_target = correct_ranks.includes(rn_edges[target_node])

              if (keep_source){  //if the source node is connected to a rank we want to display
                  new_nodes.push({data: {id: source_node, name: source_node, color: '#ADD8E6', width: 150, height: 150}})
              }
              if (keep_target){  //if the target node is connected to a rank we want to display
                  new_nodes.push({data: {id: target_node, name: target_node, color: '#ADD8E6', width: 150, height: 150}})
              }


              if (!keep_source && !keep_target){
                  //this means both the target and the source node aren't going to be added
                  var count = "pass"

              } else if (!keep_source|| !keep_target)  {
                  //adding missing: "target" regardless, b/c that's what we want to prioritize
                  //and only adding missing: "source" if the em object doesn't already have something there
                              if (!keep_source){
                                //target_node is valid source_node is going to be removed
                              
                                if (edges_missing[target_node] == undefined){
                                    new_obj = {
                                        missing: "source",
                                        old_edge: curr_edge,       
                                    }
                                    edges_missing[target_node] = new_obj //we know source_node is attached to a valid rank from else clause
                                }
                                  
                              }

                              if (!keep_target){
                                  new_obj = {
                                      missing: "target",                
                                      old_edge: curr_edge               
                                  }
                                  edges_missing[source_node] = new_obj
                              }

              } else {
                new_edges.push(curr_edge)
              }

         }
         
        //at this point don't really need to add anymore nodes
        
        for (node in edges_missing){
            curr_data = edges_missing[node]  //of the form {missing: "source/target", old_edge: {id: , source:, target: }}

            //don't need to worry about curr_data.missing target 
            if (curr_data.missing == 'target'){
                old_target = curr_data.old_edge.data.target
                curr_source = curr_data.old_edge.data.source
                //now we want to find a new target
                new_target = find_new_target(old_target, rn_edges, pc_edges, correct_ranks)
                new_edge = {data: {id: curr_source.concat('-'.concat(new_target)), source: curr_source, target: new_target, label:'subTaxOnOf'}};
                new_edges.push(new_edge)

            }
        }
    
        return {nodes: new_nodes, edges: new_edges, em: edges_missing}


    }

    </script>
  </head>

  <body>
    <script>

      function render(data, graphType) {

      var converted_data = convert_to_cytoscape(data);
      console.log(converted_data);

      if (graphType == ('Concise')){
          new_data = create_new(converted_data, ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "noRank"])
          console.log(new_data)
          nodes_lst = new_data.nodes
          edge_lst = new_data.edges
      } else if (graphType == 'Moderate') {
          new_data = create_new(converted_data, 
          ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "noRank", "Subkingdom", "Superfamily",
        "Infraclass", "Suborder", "Parvorder", "Subfamily", "Superorder", "Infraphylum", "Subtribe", "Tribe", "Megaclass", "Subclass", "Superclass",
      "Infraorder", "Subphylum"])
          console.log(new_data)
          nodes_lst = new_data.nodes
          edge_lst = new_data.edges
      }
      else {
        nodes_lst = converted_data.nodes
        edge_lst = converted_data.edges

      }


      const cyDiv = document.querySelector('#cy')
      cyDiv.style.display = 'block';
      var cy = cytoscape({
          container: document.getElementById('cy'),
          elements: {
            nodes: nodes_lst,
            edges: edge_lst
          },
          layout: {
            name: 'dagre', 
            spacingFactor: 3,
            rankDir: 'BT',
            avoidOverlap: true,
          },
          style: [
                  {
                    selector: 'node[name]',
                      style: {
                          'content': 'data(name)',
                          'text-valign': 'center',

                     }

                },
                {
                  selector: 'node',
                  style: {
                    'width': 'data(width)',
                    'height': 'data(height)',
                    'font-size': 30,
                    'background-color': 'data(color)'
                  }

                },
                {
                  selector: 'edge',
                  style: {
                      'curve-style': 'bezier',
                      'target-arrow-shape': 'triangle',
                      'label': 'data(label)',
                      'width': 10

                    }
                },
                {
                  selector: '.eh-handle',
                    style: {
                      'background-color': 'red',
                      'width': 12,
                      'height': 12,
                      'shape': 'ellipse',
                      'overlay-opacity': 0,
                      'border-width': 12, // makes the handle easier to hit
                      'border-opacity': 0
                    }
                }
              ]
      });
      
      var rank_edges = converted_data.rn_edges
      var nodes = cy.elements().nodes()

      var add_eles = []
      for (let x = 0; x < nodes.length; x++){
          node_pos = nodes[x]._private.position
          node_id = nodes[x]._private.data.id
          var x_pos = node_pos.x 
          var y_pos = node_pos.y
          var rank_node = rank_edges[node_id]
          var rank_node_id = rank_node.concat(x.toString())
          
          new_node = 
          {
            group: 'nodes',
            data: {
              id: rank_node_id,
              color: '#90EE90',
              name: rank_node,
              width: 100,
              height: 100
            },
            position: {x: x_pos - 250, y: y_pos}
          }

          add_eles.push(new_node)

          new_edge = 
              {
                group: 'edges',
                data: 
                    {
                        id: node_id.concat(rank_node),
                        source: node_id, 
                        target: rank_node_id,
                        label: 'taxonRank'
                    }
              }
          add_eles.push(new_edge)
      }
      //adding ranks to the graph along with edges

     var eles = cy.add(add_eles);

    }
    </script>


    <div id="query" style="margin: 10px">
      <h1>Knowledge Graph Query and Display</h1>
      <form class="form-inline">
        <div class="input-append">
          <input id="endpoint" class="span5" value="http://solid.boltz.cs.cmu.edu:3030/Demo/sparql" type="text" style="display:none;">
          
          <button id="Full" class="btn" type="button" onclick="exec('Full')">Full</button>
          <button id="Moderate" class="btn" type="button" onclick = "exec('Moderate')">Moderate</button>
          <button id="Concise" class="btn2" type="button" onclick = "exec('Concise')">Concise</button>
          <div id ="hierarchy-entry">
            <input id="heirarchyType" class="hierarchy-type" placeholder="Enter Hierarchy Type">
            <button onclick="gethierarchy()" class = "heirarchy-button">Enter</button>
          </div>
          
          

        </div>
      </form>
      <textarea id="sparql" class="span9" style="display:none;">
        PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
        PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
        PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/>
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX qudt:  <http://qudt.org/schema/qudt/>
        PREFIX unit:  <http://qudt.org/vocab/unit/>
        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
        PREFIX list: <http://jena.hpl.hp.com/ARQ/list#>

        SELECT DISTINCT ?root_name ?parent_name ?child_name ?rank_name
        WHERE
        {
          BIND ("Animalia"@en AS ?root_name).
          ?root kgo:taxonName ?root_name .
          ?child kgo:subTaxonOf+ ?root .
          ?child kgo:subTaxonOf ?parent .
          ?child kgo:taxonName ?child_name .
          ?child kgo:taxonRank ?rank .
          ?rank rdfs:label ?rank_name .
          ?parent kgo:taxonName ?parent_name .
        }
      </textarea>
    </div>
    <div id="cy"></div>
    <script>
      window.onload = exec('Concise');
      let fullButton = document.querySelector('#Full');
      let moderateButton = document.querySelector('#Moderate');
      let conciseButton = document.querySelector('#Concise');

      fullButton.addEventListener('click', () => fullButton.style.backgroundColor = '#4d8c57')
      fullButton.addEventListener('click', () => conciseButton.style.backgroundColor = '#000000')
      fullButton.addEventListener('click', () => moderateButton.style.backgroundColor = '#000000')


      moderateButton.addEventListener('click', () => moderateButton.style.backgroundColor = '#4d8c57')
      moderateButton.addEventListener('click', () => fullButton.style.backgroundColor = '#000000')
      moderateButton.addEventListener('click', () => conciseButton.style.backgroundColor = '#000000')


      conciseButton.addEventListener('click', () => conciseButton.style.backgroundColor = '#4d8c57')
      conciseButton.addEventListener('click', () => fullButton.style.backgroundColor = '#000000')
      conciseButton.addEventListener('click', () => moderateButton.style.backgroundColor = '#000000')

    </script> 

      
  </body>
</html>
