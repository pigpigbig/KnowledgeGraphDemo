<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <script src="external/d3.v7.min.js"></script>
    <script src="external/cytoscape.min.js"></script>

    <script src="external/dagre.js"></script>
    <script src="external/cytoscape-dagre.js"></script>

    <style type="text/css">
      html,body{
        height: 100%
      }
      #cy {
        display: none;
        height: 70%;
        width: 100%;
        border-style: solid;
      }

      .title {
        text-align: center;
      }

      .btn {
        background-color: black;
        color: white;
        padding: 10px;
        width: 100px;
      }
      

      .btn2 {
        background-color: green;
        color: white;
        padding: 10px;
        width: 100px;
      }

      .input-species {
        background-color: white;
        color: black;
        margin-top: 20px;
        margin-bottom: 20px;
        margin-right: 5px; 
        height: 20px;
        width: 150px;
      }

      .hierarchy-entry-button {
        background-color: white;
        margin-top: 20px;
        margin-bottom: 20px;
        width: 100px; 
        height: 30px;
      }
      
    </style>

    <script> 

      var my_result;
      var bindings;
      var len;
      var nodes;
      var child;
      var parent;
      var data_obj;

    function hierarchy_query(taxon_value, preform_query){
        var prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
             `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
              PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
              PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
              PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
              PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
              PREFIX qudt:  <http://qudt.org/schema/qudt/>
              PREFIX unit:  <http://qudt.org/vocab/unit/> 
              PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
              PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
              PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
              PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
              PREFIX la: <https://linked.art/ns/terms/>
              PREFIX un: <http://www.w3.org/2007/ont/unit#> 
              PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
              SELECT DISTINCT ?root_name ?root_rank ?parent_name ?parent_qval ?parent_identifier ?child_name ?child_qval ?child_identifier ?def ?root_def ?rank_name                
              WHERE 
                { 
                  BIND ('${taxon_value}'@en AS ?root_name). 
                  ?root kgo:taxonName ?root_name .  
                  ?root kgo:taxonRank [rdfs:label ?root_rank] .
                  OPTIONAL {
                    ?root skos:definition ?root_def .
                  }
                  ?child kgo:subTaxonOf* ?root . 
                  ?child kgo:subTaxonOf ?parent . 
                  ?child kgo:taxonName ?child_name .
                  OPTIONAL {
                    ?child skos:definition ?def .
                  }
                  ?child kgo:taxonRank ?rank .
                  ?rank rdfs:label ?rank_name . 
                  ?parent kgo:taxonName ?parent_name .
  	              ?child skos:prefLabel ?child_identifier .
                  ?child_qval skos:prefLabel ?child_identifier .
                  ?parent skos:prefLabel ?parent_identifier .
                  ?parent_qval skos:prefLabel ?parent_identifier .
                }`
        if (preform_query){
          var endpoint = d3.select("#endpoint").property("value")
          var sparql = d3.select("#sparql").property("value")
          var url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        }else{
          return false
        }
    }

    function property_query(taxon_value, preform_query){
      var prevquery = document.getElementById("sparql2");
      prevquery.innerHTML = 
       `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
        PREFIX dc: <http://purl.org/dc/elements/1.1/> 
        PREFIX dcterms: <http://purl.org/dc/terms/>
        PREFIX owl: <http://www.w3.org/2002/07/owl#>
        PREFIX prefix: <http://qudt.org/vocab/prefix/>
        PREFIX prov: <http://www.w3.org/ns/prov#> 
        PREFIX qkdv: <http://qudt.org/vocab/dimensionvector/> 
        PREFIX quantitykind: <http://qudt.org/vocab/quantitykind/> 
        PREFIX sou: <http://qudt.org/vocab/sou/> 
        PREFIX vaem: <http://www.linkedmodel.org/schema/vaem#> 
        PREFIX voag: <http://voag.linkedmodel.org/schema/voag#>
        PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
        PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
        PREFIX qudt:  <http://qudt.org/schema/qudt/>
        PREFIX unit:  <http://qudt.org/vocab/unit/> 
        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
        PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
        PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
        PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
        PREFIX la: <https://linked.art/ns/terms/>
        PREFIX un: <http://www.w3.org/2007/ont/unit#> 
        PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
		SELECT DISTINCT ?pred ?predLabel ?obj ?objLabel ?pred2 ?pred2Label ?list ?obj2 
        WHERE {
          BIND ( '${taxon_value}' @en AS ?name).
          ?Q skos:prefLabel|kgo:taxonName ?name.
          ?Q ?pred ?obj. 
          OPTIONAL {?Q ?pred [ list:index (?pos ?list) ] }
          OPTIONAL {?Q ?pred ?obj.
                    ?obj ?pred2 ?obj2.}
          OPTIONAL { ?pred skos:prefLabel|rdfs:label ?predLabel. } 
          OPTIONAL { ?obj skos:prefLabel|rdfs:label ?objLabel. }
          OPTIONAL { ?Q ?pred [?pred2 ?obj2].
                    ?pred2 rdfs:label|qudt:Unit ?pred2Label. }
        } ORDER BY ?pred ?pos ?pred2
            `; 

        
        if (preform_query){
          var endpoint = d3.select("#endpoint2").property("value")
          var sparql = d3.select("#sparql2").property("value")
          var url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        }else{
          return false
        }

    }

    /*convert_to_cytoscape will return an object
    that stores the nodes, the edges, the positions of all
    the nodes, and the ranks for each of the nodes*/
    function convert_to_cytoscape(data) {
        var nodes_lst = [];
        var edges_lst = [];
        var node_names = [];
        var rank_node_edges = {}; //consists of objects that have ranks and nodes that are connected by an edge
        var edge_object = {};
        var root = 'noRoot';
        var root_rank = "noRank";
        var def_for_taxons = {}
        var qvals = {}
        var root_def = "No def"

        bindings = data.results.bindings;
        len = bindings.length;

        if (len > 0){
            if (bindings [0].root_name != undefined &&
                bindings [0].root_rank != undefined &&
                bindings [0].root_def != undefined){
                  root = bindings [0].root_name.value;
                  root_rank = bindings [0].root_rank.value;
                  root_def = bindings [0].root_def.value;
                }
            
        }

        //adding nodes and definitions
        for (let i = 0; i < len; i++){
            root = bindings [i].root_name.value;
            child = bindings [i].child_name.value;
            parent = bindings [i].parent_name.value;
            rank = bindings [i].rank_name.value;
            def = bindings [i].def.value;
            child_qval = bindings [i].child_qval.value;
            parent_qval = bindings [i].parent_qval.value;

            if (child_qval.length >= 40){
              child_qval = child_qval.slice(40, child_qval.length);
            }
            if (parent_qval.length >= 40){
              parent_qval = parent_qval.slice(40, parent_qval.length);
            }
            `${child} boltz: ${child_qval.toString()}`
            child_obj = {data: {id: child, 
              name:`${child} boltz: ${child_qval.toString()}`,
               color: '#ADD8E6', width: 250, height: 250}};
            nodes_lst.push(child_obj);

            if (def_for_taxons[child] == undefined){
              def_for_taxons[child] = def;
            }
            
            qvals[child] = child_qval;
            
            parent_obj = {data: {id: parent, 
              name:`${parent} boltz: ${parent_qval.toString()}`, 
              color: '#ADD8E6', width: 250, height: 250}};
            nodes_lst.push(parent_obj);
           
            qvals[parent] = parent_qval;
          

        }
        //adding edges between parent and child
        for (let i = 0; i < len; i++){
            child = bindings [i].child_name.value;
            parent = bindings [i].parent_name.value;
            rank = bindings [i].rank_name.value;
            
            //adding an edge between the parent and child
            pc_edge = {data: {id: `${child} - ${parent}`, 
            source: child, target: parent, label:'subTaxonOf'}};
            edges_lst.push(pc_edge);

            edge_object[child] = parent; //source is the key and target is the value
            rank_node_edges[child] = rank;
            
        }

        edge_object[root] = 'root';
        rank_node_edges[root] = root_rank;
        def_for_taxons[root] = root_def;

        return {nodes: nodes_lst, edges: edges_lst, 
          rn_edges: rank_node_edges, pc_edges: edge_object, 
          root_rank: root_rank, root: root, definitions: def_for_taxons, 
          taxon_qvals: qvals};
    }



    //graphType variable is used to keep track of if the Full, Concise, or Moderate button was pressed

    function find_new_target(old_target, rn_edges, pc_edges, correct_ranks, user_entered_taxon){
        //pc_edges is an object where the sources are keys and the values are the targets
        var curr_source = old_target;
        var curr_target = pc_edges[curr_source];
        var is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);

        while (!is_valid_rank && curr_target != user_entered_taxon) {
           curr_source = curr_target; //idea is to keep "climbing up" this tree
           //assumption is that curr_source is never going to be undefined
           curr_target = pc_edges[curr_source];
           is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);
        }
        return curr_target;
    }
    
    /*so we're given the original nodes and edges and we want to output new nodes/edges
    such that there are only nodes with ranks: correct_ranks.
    if a user enters a taxon in the textbox we automatically want to keep this value
    all missing edges are filled in, also will want to return the rn_edges */
    function create_new(data, correct_ranks, user_entered_taxon){

        var nodes = data.nodes;
        var edges = data.edges;
        var rn_edges = data.rn_edges;
        var pc_edges = data.pc_edges;  //keys are sources and values are targets
        var new_edges = [];
        var new_nodes = [];
        var edges_missing = {}; //keeps track of the nodes that now no longer have edges because of the removed ranks
        var taxon_qvals = data.taxon_qvals;

        //iterating through all the edges and figuring out which ones are going to be removed 
        for (let i = 0; i < edges.length; i++){
              curr_edge = edges[i];  //of the form: {id: __, source: '', target: '', ...}
              source_node = curr_edge.data.source;
              target_node = curr_edge.data.target;
              keep_source = correct_ranks.includes(rn_edges[source_node]);
              keep_target = correct_ranks.includes(rn_edges[target_node]);
              source_node_name = `${source_node} boltz:${taxon_qvals[source_node].toString()}`;
              target_node_name = `${target_node} boltz:${taxon_qvals[target_node].toString()}`;

              if (source_node == user_entered_taxon){
                keep_source = true;
              }
              else if (target_node == user_entered_taxon){
                keep_target = true;
              }

              if (keep_source){  //if the source node is connected to a rank we want to display
                  new_nodes.push({data: {id: source_node, 
                    name: source_node_name, color: '#ADD8E6', width: 250, height: 250}});
              }
              if (keep_target){  //if the target node is connected to a rank we want to display
                  new_nodes.push({data: {id: target_node, 
                    name: target_node_name, color: '#ADD8E6', width: 250, height: 250}});
              }


              if (!keep_source && !keep_target){
                  //this means both the target and the source node aren't going to be added
                  var count = "pass";

              } else if (!keep_source|| !keep_target)  {
                  //adding missing: "target" regardless, b/c that's what we want to prioritize
                  //and only adding missing: "source" if the em object doesn't already have something there
                              if (!keep_source){
                                //target_node is valid source_node is going to be removed
                              
                                if (edges_missing[target_node] == undefined){
                                    new_obj = {
                                        missing: "source",
                                        old_edge: curr_edge,       
                                    };
                                    edges_missing[target_node] = new_obj;
                                    //we know source_node is attached to a valid rank from else clause
                                }
                                  
                              }

                              if (!keep_target){
                                  new_obj = {
                                      missing: "target",                
                                      old_edge: curr_edge               
                                  };
                                  edges_missing[source_node] = new_obj;
                              }

              } else {
                new_edges.push(curr_edge);
              }

         }
         
        //at this point don't really need to add anymore nodes
        
        for (node in edges_missing){
            curr_data = edges_missing[node]  ;
            //of the form {missing: "source/target", old_edge: {id: , source:, target: }}

            //don't need to worry about curr_data.missing target 
            if (curr_data.missing == 'target'){
                old_target = curr_data.old_edge.data.target;
                curr_source = curr_data.old_edge.data.source;
                //now we want to find a new target
                new_target = find_new_target(old_target, 
                rn_edges, pc_edges, correct_ranks, user_entered_taxon);

                new_edge = {data: {id: `${curr_source} - ${new_target}`, 
                source: curr_source, target: new_target, label:'subTaxonOf'}};
                new_edges.push(new_edge);

            }
        }
        
        return {nodes: new_nodes, edges: new_edges, em: edges_missing};


    }
      //when a specific node is clicked,i.e. node_name
      //all other nodes and edges become transparent
      function shade_other_nodes(node_name, cy_graph){
          cy_graph.elements().nodes().style( { 'opacity' : '.2', 'text-opacity':0 });


          var id_label = `[id = '${node_name}']`;
    
          cy_graph.nodes(id_label).style({
                      'background-color': '#FFB6C1',
                      'text-opacity': '1',
                      'opacity': '1',
                      'text-wrap': 'wrap',
                      'text-max-width': 125,
                      'border-width': 5,
                      'border-color': '#FF007F',
                      'border-style': 'solid',
                      'font-size': 30,
                      'font-family': 'Garamond',
                      'line-height': 1.15
          });
      
          cy_graph.elements().edges().style( { 'line-opacity' : '.2', 'text-opacity':'0' });
      }




      /*takes in an array of objects from a property query
      and outputs a new array that eliminates redundancy*/
      function trim_prop_query(property_array){
        //we are going to be looking for a repeat of objLabel and predLabel
        var obj_labels = [];
        var new_property_array = [];

        //also don't want to count a bnode as multiple nodes
        var bnodes = {};
        var bnode_obj_values = [];
        var curr_bnode_num = 'b0';
        
        for (let i = 0; i < property_array.length; i ++){
            var curr_data_val = property_array[i];
            //first check if we have a bnode, if we do automatically add it to our array
            if (curr_data_val.obj != undefined &&
                curr_data_val.obj.type == 'bnode'){
                    
                    var bnode_num = curr_data_val.obj.value;
                    if (bnode_num != curr_bnode_num){
                      //we are now at a diff bnode_num so reset bnode_obj_values
                      //purpose of this is to avoid repeated data in the bnode_objs
                      //that are going to be returned
                      bnode_obj_values = [];
                      curr_bnode_num = bnode_num;
                    }

                    var bnode_obj = {};

                    if (curr_data_val.pred2 != undefined 
                      && curr_data_val.obj2 != undefined){
                            
                            //first need to check that this node_value isn't already added
                            var obj2_value = curr_data_val.obj2.value;
                            if (!(bnode_obj_values.includes(obj2_value))){
                                  var bnode_obj = {pred2: curr_data_val.pred2.value,
                                  obj2: obj2_value,
                                  pred2Label: curr_data_val.pred2Label};

                                  if (bnodes[bnode_num] == undefined){
                                    bnodes[bnode_num] = [bnode_obj];
                                    new_property_array.push(curr_data_val);
                                  }else{
                                    bnodes[bnode_num].push(bnode_obj);
                                  }

                                  bnode_obj_values.push(obj2_value);

                            }
                            
                    }
                    
                    

            }
            //next check for redundant object labels
            //assumption is that we can have redundant
            //predLabels (i.e. two defintions could be possible)
            else if (curr_data_val.objLabel != undefined){
              var obj_label = curr_data_val.objLabel.value;
              if (!(obj_labels.includes(obj_label))){
                  obj_labels.push(obj_label);
                  new_property_array.push(curr_data_val);
              }
            }else{
              new_property_array.push(curr_data_val);
            }

        }
        console.log("new_prop_array", new_property_array);
        console.log("bnode_objects", bnodes);
        return {prop_array: new_property_array, bnodes_obj: bnodes};
        

      }

      function add_values_to_bnodes(bnodes, bnode_objects, cy_graph){
          var diam = 110;
          for (let x = 0; x < bnodes.length; x ++){

              var bnode_pos = bnodes[x].position;
              var bnode_number = bnodes[x].data.id;
              var x_pos = bnode_pos.x;
              var y_pos = bnode_pos.y;
              var added_els = [];
              var num_bnode_values = bnode_objects[bnode_number].length;
              console.log("num", num_bnode_values);
              var mult_constant = 5;

              var circumference = num_bnode_values * diam;
              var radius = circumference / (2* Math.PI);
              var curr_degree = .52;
              var degree_movement = (2 * Math.PI) / num_bnode_values;

              var next_x_pos = x_pos + (radius*mult_constant)*(Math.cos(curr_degree));
              var next_y_pos = y_pos + (radius*mult_constant)*(Math.sin(curr_degree));

              var new_degree = 0;
              var bnode_vals = [];

              var curr_bnode_vals = bnode_objects[bnode_number];
              console.log("bnode num", bnode_number);
              for (let i = 0; i < num_bnode_values; i++){
                    var curr_bnode_val = curr_bnode_vals[i].obj2;
                    var curr_edge_label = curr_bnode_vals[i].pred2;
                    if (curr_bnode_vals[i].pred2Label != undefined){
                      curr_edge_label = curr_bnode_vals[i].pred2Label.value;
                    }
                    var node_id = curr_bnode_val;
                    node_id = `${curr_bnode_val} - ${bnode_number}`;
                  
                    console.log("curr_bnode_val", curr_bnode_val);
                    if (curr_bnode_val != undefined){  
          
                                  var new_property_node = 
                                            {
                                                group: 'nodes',
                                                data: {
                                                  id: node_id,
                                                  color: '#FFD580',
                                                  name: curr_bnode_val,
                                                  opacity: 1,
                                                  width: diam,
                                                  height: diam
                                                },
                                                position: {x: next_x_pos, y: next_y_pos}
                                            };
                                    
                                    
                                    added_els.push(new_property_node);

                                   var new_edge = 
                                            {
                                              group: 'edges',
                                              data: 
                                                  {
                                                      id: node_id.concat(bnode_number),
                                                      source: bnode_number, 
                                                      target: node_id,
                                                      label: curr_edge_label
                                                  }
                                            };

                                      added_els.push(new_edge);

                                    
                                      var new_degree = (curr_degree + degree_movement) % (2 * Math.PI);

                                      var next_x_pos = x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                                      var next_y_pos = y_pos + (radius*mult_constant)*(Math.sin(new_degree));
                                        
                                      curr_degree = new_degree;
                        }

              }
              
              cy_graph.add(added_els);
              var id_selector = `node[width = ${diam}]`;
                    cy_graph.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Garamond',
                      'line-height': 1.15
                    });

          }


      }

      //adds the nodes and edges that resemble the properties for the
      //node with id node_name
      function create_property_nodes(node_name, data, cy_graph, pos, pc_edges, prop_node_diam){
            var prop_node_height = prop_node_diam;
            var x_pos = pos.x;
            var y_pos = pos.y;
            var added_els = [];

            
            //first want to trim down our redundancy in our query
            var new_prop_data = trim_prop_query(data.results.bindings);

            var bnode_objects = new_prop_data.bnodes_obj;
            var new_property_array = new_prop_data.prop_array;
            var num_property_nodes = new_property_array.length;

            var mult_constant = 10;
            //var mult_constant = prop_node_diam/num_property_nodes;


            //calculate placement of first property node
            var circumference = num_property_nodes * 50;
            var radius = circumference / (2* Math.PI);
            var curr_degree = 0;
            var degree_movement = (2 * Math.PI) / num_property_nodes;

            var next_x_pos = x_pos + (radius* (mult_constant));
            var next_y_pos = y_pos;
            var x_constant = 1;
            var y_constant = 1;
            var new_degree = 0;
            var bnodes = [];

            /*temporarily first get the number of property nodes we want until query issue is fixed*/
		
            for (let x = 0; x < num_property_nodes; x ++){

                  //we want the object label and the predlabel  
                  var prop_node_val = new_property_array[x].objLabel ? new_property_array[x].objLabel.value : new_property_array[x].obj.value;
                  var pred_val = new_property_array[x].predLabel ? new_property_array[x].predLabel.value : new_property_array[x].pred.value;

                  var prop_node_type = new_property_array[x].obj.type;
                  var num_lines = Math.ceil((prop_node_val.length)/15);
                  prop_node_height = num_lines * 50 + 50;

                  var node_id = prop_node_val;
                  //check to see if it's not already a node on the graph
                  if (pc_edges[prop_node_val] != undefined || 
                      prop_node_val == "Biota" || prop_node_val == node_name){
                      node_id = prop_node_val.concat(x.toString());
                  }
                  if (prop_node_type == 'literal'){
                      prop_node_val = `"${prop_node_val}"`;
                  }

                  if (pred_val == 'definition'){
                    node_id = `${prop_node_val} - def`;
                  }

                  if (prop_node_val != undefined){  

                              if (prop_node_type == "bnode"){
                                  var next_x_pos = x_pos + (radius*1.5*mult_constant)*(Math.cos(curr_degree));
                                  var next_y_pos = y_pos + (radius*1.5*mult_constant)*(Math.sin(curr_degree));
                              }
          
                              var new_property_node = 
                                        {
                                            group: 'nodes',
                                            data: {
                                              id: node_id,
                                              color: '#FFD580',
                                              name: prop_node_val,
                                              opacity: 1,
                                              width: prop_node_diam,
                                              height: prop_node_height
                                            },
                                            position: {x: next_x_pos, y: next_y_pos}
                                        };
                                
                                if (prop_node_type == 'bnode'){
                                  bnodes.push(new_property_node);
                                  
                                }
                                added_els.push(new_property_node);
                                

                                var new_edge = 
                                        {
                                          group: 'edges',
                                          data: 
                                              {
                                                  id: node_id.concat(node_name),
                                                  source: node_name, 
                                                  target: node_id,
                                                  label: pred_val
                                              }
                                        };

                                  added_els.push(new_edge);

                                
                                  var new_degree = (curr_degree + degree_movement) % (2 * Math.PI);

                                  var next_x_pos = x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                                  var next_y_pos = y_pos + (radius*mult_constant)*(Math.sin(new_degree));
                                    
                                  curr_degree = new_degree;
                    }
                        
              }     

                    cy_graph.add(added_els);
                    add_values_to_bnodes(bnodes, bnode_objects, cy_graph);

                    var id_label = `[id = '${node_name}']`


                    var clientWidth = document.getElementById('cy').clientWidth;
                    var clientHeight = document.getElementById('cy').clientHeight;
                    var smaller_space = Math.min(clientWidth, clientHeight);

                    //for num_property_nodes = 9, want clientHeight / 2.17
                    //for num_property_nodes = 6, want clientHeight / 2.4;
                    var padding_amount = Math.floor(clientHeight / 2.4);
                    if (num_property_nodes >= 8){
                      padding_amount = Math.floor(clientHeight/2.17);
                    }

                    //zoom on the selected node enough to display all of the properties
                    cy_graph.animate({
                      fit: {
                        eles: id_label, 
                        padding: padding_amount
                      }
                    });
                    
                    var id_selector = `node[width = ${prop_node_diam.toString()}]`;

                    cy_graph.nodes(id_selector).style({
                      'shape': 'square',
                      'text-wrap': 'wrap',
                      'text-max-width': prop_node_diam - 20,
                      'border-width': 5,
                      'border-color': '#FFA500',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Garamond',
                      'line-height': 1.15
                    });
      
                    cy_graph.elements().edges().style({'font-size': '30'});
                    

          }

              
      function show_property_nodes(node_name, data, cy_graph, pc_edges, prop_node_diam){
            
            console.log("property data", data);
            
            var id_label = `[id= '${node_name}']`;
            var pos = cy_graph.nodes(id_label).position();

            shade_other_nodes(node_name, cy_graph);
            create_property_nodes(node_name, data, cy_graph, pos, pc_edges, prop_node_diam);

      }


      //returns the hierarchy back to it's original state
      //after the user unselects a node
      function return_to_normal(node_name, cy_graph, given_taxon, ranks, prop_node_diam){


            //changing the nodes back to their original styles
            cy_graph.elements().nodes().style( 
              { 'opacity' : '1',
                'text-opacity': '1'
              });

            var nodes = cy_graph.elements().nodes();
            for (let i = 0; i < nodes.length; i++){
                var curr_node_name = nodes[i]._private.data.name;
                var curr_node_id = nodes[i]._private.id;

                var id_label = `[id = '${curr_node_id}']`;

                if (ranks.includes(curr_node_name)){
                    cy_graph.nodes(id_label).style({
                      "background-color": "#90EE90",
                      'text-wrap': 'wrap',
                      'text-max-width': 150,
                      'font-size': 35,
                      'font-family': 'Garamond',
                      'line-height': 1.15
                    });
                }else{
                    cy_graph.nodes(id_label).style("background-color", "#ADD8E6");
                }
            }

            var id_label = `[id = '${node_name}']`;
            cy_graph.nodes(id_label).style("background-color", "#ADD8E6");
            
            var id_label = `[id = '${given_taxon}']`;
            cy_graph.nodes(id_label).style("background-color", "red");

            //changing the edges back to their original styles
            cy_graph.elements().edges().style( 
              { 'line-opacity' : '1',
                'text-opacity': '1'
              });
            cy_graph.elements().nodes().style({'border-width': '0'});
            
            var node_id_removed = `node[width = ${prop_node_diam.toString()}]`;
            
            cy_graph.remove(node_id_removed);
            cy_graph.remove("node[width = 110]");
            cy_graph.animate({
              fit: {
                padding: 20
              }
            });
      }

      //only want this function to preform the query if we select a non-rank node
      function get_properties(node_name, cy_graph, moderate_ranks, pc_edges, prop_node_diam){
  
        if (moderate_ranks.includes(node_name) || node_name == "Clade"){
          return false;
        }
        var url = property_query(node_name, true);
          d3.json(url).then(function(json){
            show_property_nodes(node_name, json, cy_graph, pc_edges, prop_node_diam)
          })
      }

      function get_definition(node_name, cy_graph, moderate_ranks, definitions, definition_node_size){

          if (moderate_ranks.includes(node_name) || node_name == "Clade"){
            return false;
          }
          var def_node_height;
        
          var taxon_def = definitions[node_name];
          if (taxon_def == undefined || taxon_def == ""){
            taxon_def = "No definition available";
          }
          var id_label = `[id = '${node_name}']`;
          var pos = cy_graph.nodes(id_label).position();

          var def_length = taxon_def.length;
          
          var num_lines = Math.ceil(def_length/15);
          var definition_node_height = num_lines*90 + 50;
          

          def_node = {
                              group: 'nodes',
                              data: {
                                id: taxon_def,
                                color: '#FFB6C1',
                                name: taxon_def,
                                opacity: 1,
                                width: definition_node_size,
                                height: definition_node_height,
                              },
                               position: {x: pos.x + 500 , y: pos.y}
                          };
          def_edge = {
                            group: 'edges',
                            data: 
                                {
                                    id: def.concat(node_name),
                                    source: node_name, 
                                    target: taxon_def,
                                    label: 'DEF',
                                }
                          };
          cy_graph.add(def_node);
          cy_graph.add(def_edge);

          var id_selector = `node[width = ${definition_node_size.toString()}]`;
          cy_graph.style().selector(id_selector).style({
            'shape': 'rectangle',
            'text-wrap': 'wrap',
            'text-max-width': definition_node_size - 20,
            'border-width': 20,
            'border-color': '#FF007F',
            'border-style': 'solid',
            'font-size': 75,
            'font-family': 'Garamond',
            'line-height': 1.15

          });
          var edge_id_label = `[id = '${def.concat(node_name)}']`;
          cy_graph.edges(edge_id_label).style({
            'line-color': '#FF007F',
            'target-arrow-color': '#FF007F',
            'color': 'white',
            'width': 20
          });
          
      }

    function exec(graphType){
      var url = hierarchy_query("Biota", true);
      d3.json(url).then(function(json_result){
        display_hierarchy(json_result, graphType, {given_data: 'null', taxon_value: "null"}, "root");
      });
    }


    //givenData is an object {given_data: 'null'} if we're not going to be given anything, otherwise
    //{given_data: {...}} where {...} is what convert_to_cytoscape(data) would print out
    function display_hierarchy(data, graphType, givenData, given_taxon) {
	      console.log("json data is", data);

        var user_entered_taxon = givenData.taxon_value;
        if (givenData.given_data != 'null'){ 
          //this implies we are already given what convert_to_cytoscape would produce
            var converted_data = givenData.given_data;
        }else{
            var converted_data = convert_to_cytoscape(data);
        }
        var root_rank = converted_data.root_rank;
        var root = converted_data.root;
	      var pc_edges = converted_data.pc_edges;
        var definitions = converted_data.definitions;
        var taxon_qvals = converted_data.taxon_qvals;

        //this will mainly be used to pass into other fns to know what nodes
        //already exist in our graph
        
        var moderate_ranks = [ "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", 
            "Species", "noRank", "Subkingdom", "Superfamily", "Infraclass", "Suborder", 
            "Parvorder", "Subfamily", "Superorder", "Infraphylum", "Subtribe", "Tribe", 
            "Megaclass", "Subclass", "Superclass","Infraorder", "Subphylum", "Variety", 
            "Superphylum", "Division", "Domain", "Subdivision", root_rank];
        
        var concise_ranks = [
              root_rank, "Kingdom", "Phylum", "Class", 
              "Order", "Family", "Genus", "Species", "noRank"];

        if (graphType == ('Concise')){

            new_data = create_new(converted_data, concise_ranks, user_entered_taxon);
            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;

        } else if (graphType == 'Moderate') {

            new_data = create_new(converted_data, moderate_ranks, user_entered_taxon);

            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;
        }
        else {
          nodes_lst = converted_data.nodes;
          edge_lst = converted_data.edges;
        }
        
        const cyDiv = document.querySelector('#cy');
        cyDiv.style.display = 'block';
        var cy = cytoscape({
            container: document.getElementById('cy'),
            elements: {
              nodes: nodes_lst,
              edges: edge_lst
            },
            layout: {
              name: 'dagre', 
              spacingFactor: 3,
              rankDir: 'BT',
              avoidOverlap: true,
            },
            style: [
                    {
                      selector: 'node[name]',
                        style: {
                            'content': 'data(name)',
                            'text-valign': 'center',

                      }

                  },
                  {
                    selector: 'node',
                    style: {
                      'width': 'data(width)',
                      'height': 'data(height)',
                      'font-size': 30,
                      'background-color': 'data(color)'
                    }

                  },
                  {
                    selector: 'edge',
                    style: {
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'triangle',
                        'label': 'data(label)',
                        'width': 10

                      }
                  },
                  {
                    selector: '.eh-handle',
                      style: {
                        'background-color': 'red',
                        'width': 12,
                        'height': 12,
                        'shape': 'ellipse',
                        'overlay-opacity': 0,
                        'border-width': 12, // makes the handle easier to hit
                        'border-opacity': 0
                      }
                  }
                ]
        });
        
        var rank_edges = converted_data.rn_edges;
        var nodes = cy.elements().nodes();

        var rank_node_id;

        var add_eles = []
        for (let x = 0; x < nodes.length; x++){
            node_pos = nodes[x]._private.position;
            node_id = nodes[x]._private.data.id;
            var x_pos = node_pos.x ;
            var y_pos = node_pos.y;
            var rank_node = rank_edges[node_id];
            var rank_node_id = rank.node;
            if (rank_node_id == undefined){
              rank_node_id = `noRank ${x.toString()}`;
            }else{
              rank_node_id = rank.node.concat(x.toString());
            }
            
            //rank_node_id is undefined in some places

            new_node = 
            {
              group: 'nodes',
              data: {
                id: rank_node_id,
                color: '#90EE90',
                name: rank_node,
                width: 100,
                height: 100
              },
              position: {x: x_pos - 350, y: y_pos}
            };

            add_eles.push(new_node);

            new_edge = 
                {
                  group: 'edges',
                  data: 
                      {
                          id: node_id.concat(rank_node),
                          source: node_id, 
                          target: rank_node_id,
                          label: 'taxonRank'
                      }
                };
            add_eles.push(new_edge);
        }
        //adding ranks to the graph along with edges

          var eles = cy.add(add_eles);
          cy.elements().edges().style( { 'font-size' : '27' });
          cy.elements().nodes().style({
            'font-family': 'Garamond'
          });

          var prop_node_diam = 300
          var definition_node_size = 600

          if (given_taxon == "root"){
            var id_label = `[id = '${root}']`;
            given_taxon = root;
          } else {
            var id_label = `[id = '${given_taxon}']`;
          }
          cy.nodes(id_label).style('background-color', 'red');

          var id_selector = "node[width = 250]";
                    cy.nodes(id_selector).style({
                      'text-wrap': 'wrap',
                      'text-max-width': 150,
                      'font-size': 35,
                      'font-family': 'Garamond',
                      'line-height': 1.15
                    });
      
          

          cy.nodes().on('select', function(evt){
                var name = this._private.data.name;
                if (!(moderate_ranks.includes(name) || name == "Clade")){
                    get_properties(this.id(), cy, moderate_ranks, pc_edges, prop_node_diam);
                }
          })
          .on('unselect', function(evt){
                return_to_normal(this.id(), cy, given_taxon, moderate_ranks, prop_node_diam);
            
          })
          
          .on("mouseover", function(evt){
                var name = this._private.data.name;
                if (!(moderate_ranks.includes(name) || name == "Clade")){
                  get_definition(this.id(), cy, moderate_ranks, definitions, definition_node_size);
                }
              
          })
          
          .on("mouseout", function(evt){
            var id_selector = `node[width = ${definition_node_size.toString()}]`;
            cy.remove(id_selector);
          })

    }


      //changes the buttons for the new input node 
      function change_buttons(new_data, full_json, rootVal){
            document.getElementById("Full").onclick = 
                  function () {display_hierarchy(full_json, 'Full', {given_data: new_data, taxon_value: rootVal}, rootVal)};

            document.getElementById("Moderate").onclick = 
                  function () {display_hierarchy(full_json, 'Moderate', {given_data: new_data, taxon_value: rootVal}, rootVal)};

            document.getElementById("Concise").onclick = 
                  function () {display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: rootVal}, rootVal)};

      }

    /*transform_data is a function that takes in the query from the new root node
    and then updates it so that it returns all the nodes above the queried node*/
    function transform_data(short_json, full_json, rootVal){
          
          var short_data = convert_to_cytoscape(short_json);
          var full_data = convert_to_cytoscape(full_json);
          var old_pc_edges = short_data.pc_edges;
          var pc_edges = full_data.pc_edges; //grabs the source-target edges so that we can form new edges and add new nodes
          var root = full_data.root;
          var old_nodes = short_data.nodes;

          if (pc_edges[rootVal]== undefined){
            console.log('error');
            //now we want to tell the user they have input something invalid
            var place = document.getElementById("hierarchy-entry");
            var error_message = document.createElement("p");
            error_message.innerHTML = `Concept '${rootVal}' is not found. Please try again.`;
            error_message.id = "error_message";
            place.appendChild(error_message);
            error_message.style.color = 'red';
            return false;
          }

          var old_edges = short_data.edges;
          var curr_node = rootVal;
          var next_node;

          while (curr_node != root){
            next_node = pc_edges[curr_node];
            //add this node and a new edge
            var new_node = {data: {id: next_node, name: next_node, 
              color: '#ADD8E6', width: 150, height: 150}};
            old_nodes.push(new_node);
            
            //only add a new edge if it hasn't already been added
            if (old_pc_edges[curr_node] == undefined){
              var new_edge = {data: {id: curr_node.concat(next_node), 
                source: curr_node, target: next_node, label: 'subTaxonOf'}};
              old_edges.push(new_edge);
            }

            curr_node = next_node;
          }
          var new_data = {edges: old_edges, nodes: old_nodes, 
            pc_edges: pc_edges, rn_edges: full_data.rn_edges, 
            root_rank: full_data.root_rank, root: full_data.root, 
            definitions: full_data.definitions, taxon_qvals: full_data.taxon_qvals};
          //so we've updated our edges and nodes to include the ones above the root we queried, so 
          //now we want to display the graph.

          change_buttons(new_data, full_json, rootVal);
          display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: rootVal}, rootVal);
          document.getElementById("Concise").style.background='green';
          document.getElementById("Moderate").style.background='black';
          document.getElementById("Full").style.background='black';

    }


    function change_to_root(){
          hierarchy_query("Biota", false);

          document.getElementById("Full").onclick = 
                function () {exec('Full')};

          document.getElementById("Moderate").onclick = 
                function () {exec('Moderate')};
          document.getElementById("Concise").onclick = 
                function () {exec('Concise')};

          exec('Concise');
          document.getElementById("Concise").style.background='green';
          document.getElementById("Moderate").style.background='black';
          document.getElementById("Full").style.background='black';

          //removing the back to root button because we don't need it
          //if we're already at the root

          var btn = document.getElementById('changetoRoot_button');
          btn.parentNode.removeChild(btn);
          document.getElementById("hierarchySpecies").value = "";
          var el2 = document.getElementById('error_message');
          if (el2 != null){
            el2.parentNode.removeChild(el2);
          }

    }

      function gethierarchy(){
        
        //check if a "backtoroot" button exists and if it does get rid of it
        var el = document.getElementById('changetoRoot_button');
        if (el != null){
           el.parentNode.removeChild(el);
        }

        var el2 = document.getElementById('error_message');
        if (el2 != null){
          el2.parentNode.removeChild(el2);
        }

        var place = document.getElementById("hierarchy-entry");
        var backtoRoot_btn = document.createElement("button");
        backtoRoot_btn.innerHTML = "Back to Root";
        place.appendChild(backtoRoot_btn);
        backtoRoot_btn.setAttribute('id',"changetoRoot_button");
        backtoRoot_btn.style.backgroundColor = 'salmon';
        backtoRoot_btn.style.width = '100px';
        backtoRoot_btn.style.height = '30px';
       /* backtoRoot_btn.setAttribute('style',"width: 100px")
        backtoRoot_btn.setAttribute('style',"height: 30px")*/



        backtoRoot_btn.className = "change-root-button";
        backtoRoot_btn.type = "button";
        backtoRoot_btn.addEventListener('click', function (){
          change_to_root();
        })


        var hierarchyVal = document.getElementById("hierarchySpecies").value;
        if (hierarchyVal.length >= 2){
            hierarchyVal = hierarchyVal.charAt(0).toUpperCase()
             + (hierarchyVal.toLowerCase()).slice(1);
          }
        var prevquery = document.getElementById("sparql");
        var old_prevquery = prevquery.value;

        //gets the old url
        var endpoint2 = d3.select("#endpoint").property("value");
        var sparql2 = d3.select("#sparql").property("value");
        var url2 = endpoint2 + "?query=" + encodeURIComponent(sparql2); 
        
        //new url
        var url = hierarchy_query(hierarchyVal, true);

          prevquery.innerHTML = old_prevquery;
          document.getElementById("hierarchySpecies").value = "";

          d3.json(url).then(function(json1){
                d3.json(url2).then(function(json2){
                  transform_data(json1, json2, hierarchyVal);
                })
          });
      }
    </script>
  </head>


  <body>


    <div id="query" style="margin: 10px">
      <h1 class = 'title'>Knowledge Graph Query and Display</h1>
      <form class="form-inline">
        <div class="input-append">
          
          <input id="endpoint" class="span5" value="http://solid.boltz.cs.cmu.edu:3030/Demo/sparql" type="text" style="display:none;">

          <button id="Full" class="btn" type="button" onclick="exec('Full')">Full</button>
          <button id="Moderate" class="btn" type="button" onclick = "exec('Moderate')">Moderate</button>
          <button id="Concise" class="btn2" type="button" onclick = "exec('Concise')">Concise</button>
          <div id ="hierarchy-entry">
            <input id="hierarchySpecies" class="input-species" placeholder="Enter Taxon Name">
          </div>

        </div>
      </form>
      <textarea id="sparql" class="spans9" style="display:none;"></textarea>

      <input id="endpoint2" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Demo/sparql" type="text" style="display:none;">
      <textarea id="sparql2" class="spans10" style="display:none;"></textarea>

    </div>
    <div id="cy"></div>
    <script>
      window.onload = exec('Concise');
      let fullButton = document.querySelector('#Full');
      let moderateButton = document.querySelector('#Moderate');
      let conciseButton = document.querySelector('#Concise');

      fullButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = 'green')

      fullButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = '#000000')

      fullButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')


      moderateButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = 'green')

      moderateButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')

      moderateButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = '#000000')


      conciseButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = 'green')

      conciseButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')

      conciseButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')

      var taxonSpecies = document.getElementById("hierarchySpecies");
        taxonSpecies.addEventListener("keydown", function (e){
          if (e.key == "Enter"){
            gethierarchy();
          }
        });

    </script> 
      
  </body>
</html>
